<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giveaway Wheel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .container {
            text-align: center;
            max-width: 800px;
            width: 100%;
            padding: 20px;
        }

        h1 {
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .wheel-container {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .wheel-canvas {
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            transition: transform 0.1s ease-out;
        }

        .wheel-pointer {
            position: absolute;
            top: 50%;
            right: -15px;
            width: 0;
            height: 0;
            border-left: 20px solid #ff4444;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            z-index: 10;
            transform: translateY(-50%);
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        .wheel-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            border: 3px solid #fff;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .controls {
            margin: 30px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        input[type="text"] {
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            min-width: 200px;
        }

        select {
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            background: white;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn-success {
            background: linear-gradient(45deg, #00b894, #00a085);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .entrants-list {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .entrant-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            transition: background 0.3s ease;
        }

        .entrant-item:hover {
            background: rgba(255,255,255,0.2);
        }

        .platform-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 8px;
        }

        .platform-twitch { background: #9146ff; color: white; }
        .platform-youtube { background: #ff0000; color: white; }
        .platform-facebook { background: #1877f2; color: white; }
        .platform-instagram { background: #e4405f; color: white; }
        .platform-tiktok { background: #000000; color: white; }
        .platform-discord { background: #5865f2; color: white; }
        .platform-kick { background: #53fc18; color: black; }

        .winner-display {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.5em;
            font-weight: bold;
            text-shadow: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            display: none;
        }

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #f94144;
            z-index: 1000;
            pointer-events: none;
        }

        /* OBS Mode Styles */
        .obs-mode {
            background: transparent !important;
            padding: 0 !important;
        }

        .obs-mode .container {
            background: transparent;
            box-shadow: none;
        }

        .obs-mode h1 {
            display: none;
        }

        .obs-mode .controls {
            display: none;
        }

        .obs-mode .entrants-list {
            display: none;
        }

        @media (max-width: 768px) {
            .wheel-container {
                width: 300px;
                height: 300px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            input[type="text"] {
                min-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Giveaway Wheel</h1>
        
        <div class="wheel-container" id="wheel-container">
            <div class="wheel-pointer"></div>
            <canvas id="wheel-canvas" class="wheel-canvas" width="400" height="400"></canvas>
            <div class="wheel-center"></div>
        </div>

        <div class="winner-display" id="winner-display"></div>

        <div class="controls">
            <div class="keyword-section" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <h3>üîë Entry Keyword</h3>
                <div style="font-size: 1.5em; color: #FFD700; margin: 10px 0;">
                    Current Keyword: <strong id="current-keyword">ENTER</strong>
                </div>
                <div style="font-size: 0.9em; color: #ccc; margin-bottom: 10px;">
                    Viewers type this keyword in chat to enter the giveaway
                </div>
                <div style="margin: 10px 0;">
                    <input type="text" id="keyword-input" placeholder="Enter new keyword..." style="padding: 8px; margin-right: 10px; border: 1px solid #ddd; border-radius: 4px;">
                    <button class="btn-secondary" onclick="setKeyword()">Set Keyword</button>
                </div>
                <button class="btn-secondary" onclick="openOBSWidget()">üì∫ Open OBS Widget</button>
            </div>

            <div class="input-group">
                <input type="text" id="entrant-name" placeholder="Enter participant name">
                <select id="platform-select">
                    <option value="twitch">Twitch</option>
                    <option value="youtube">YouTube</option>
                    <option value="facebook">Facebook</option>
                    <option value="instagram">Instagram</option>
                    <option value="tiktok">TikTok</option>
                    <option value="discord">Discord</option>
                    <option value="kick">Kick</option>
                </select>
                <button class="btn-secondary" onclick="addEntrant()">Add Participant</button>
            </div>
            
            <div class="input-group">
                <button class="btn-primary" onclick="spinWheel()" id="spin-btn">üéØ Spin the Wheel!</button>
                <button class="btn-success" onclick="clearEntrants()">Clear All</button>
                <button class="btn-secondary" onclick="addTestData()">Add Test Data</button>
                <button onclick="clearAllEntries()" style="background-color: #dc3545; color: white; padding: 12px 24px; border: none; border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer;">üóëÔ∏è Clear All Entries</button>
            </div>
        </div>

        <div class="entrants-list">
            <h3>Participants (<span id="entrant-count">0</span>)</h3>
            <div id="entrants-container"></div>
        </div>
    </div>

    <script>
        // üêõ DEBUGGING VARIABLES
        let messageCount = 0;
        let debugStartTime = new Date();
        
        console.log('üéØ GIVEAWAY PAGE LOADED');
        console.log('‚è∞ Load time:', debugStartTime.toISOString());
        console.log('üåê Page URL:', window.location.href);
        console.log('üì± User Agent:', navigator.userAgent);
        console.log('üîß Console debugging enabled');
        
        // Global state
        let entrants = {};
        let isSpinning = false;
        let isOBSMode = false;
        let currentKeyword = 'ENTER';
        
        // Social Stream WebRTC integration
        let iframe = null;
        let roomID = "test";
        let password = "false";
        
        // Get session ID and password from URL parameters
        console.log('üîç PARSING URL PARAMETERS...');
        const urlParams = new URLSearchParams(window.location.search);
        console.log('üìã All URL params:', Array.from(urlParams.entries()));
        
        if (urlParams.has("session")) {
            roomID = urlParams.get("session");
            console.log('‚úÖ Found session parameter:', roomID);
        } else if (urlParams.has("s")) {
            roomID = urlParams.get("s");
            console.log('‚úÖ Found s parameter:', roomID);
        } else if (urlParams.has("id")) {
            roomID = urlParams.get("id");
            console.log('‚úÖ Found id parameter:', roomID);
        } else {
            console.log('‚ùå No session parameter found! Using default:', roomID);
            console.log('üí° Add ?session=YOUR_SESSION_ID to the URL to connect');
        }
        
        if (urlParams.has("password")) {
            password = urlParams.get("password") || "false";
            console.log('üîë Found password parameter:', password);
        } else {
            console.log('üîì No password parameter found, using default:', password);
        }
        
        console.log('üéØ Final connection parameters:');
        console.log('  üìã Room ID:', roomID);
        console.log('  üîë Password:', password);

        // Platform icon cache
        let platformIconCache = {};
        
        // WebRTC iframe setup for Social Stream integration
        function setupWebRTCConnection() {
            if (!roomID || roomID === "test") {
                console.log("No session ID provided. Add ?session=YOUR_SESSION_ID to URL to connect to Social Stream");
                return;
            }
            
            console.log('üöÄ STARTING WEBRTC CONNECTION SETUP...');
            console.log('üìã Session ID:', roomID);
            console.log('üîë Password:', password);
            console.log('üåê Current URL:', window.location.href);
            
            // Create hidden iframe for WebRTC connection
            iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.allow = "midi;geolocation;microphone;"; // microphone needed for Safari WebRTC P2P connections
            iframe.connectedPeers = {};
            
            // Connect as a view-only client to receive chat messages
            iframe.src = "https://vdo.socialstream.ninja/?ln&salt=vdo.ninja&password="+password+"&push&label=dock&vd=0&ad=0&novideo&noaudio&autostart&cleanoutput&room="+roomID;
            
            console.log('üîó Iframe URL:', iframe.src);
            console.log('üìè URL Length:', iframe.src.length);
            
            // Add detailed load event listeners
            iframe.onload = function() {
                console.log('‚úÖ Iframe loaded successfully!');
                console.log('üìç Iframe contentWindow:', !!iframe.contentWindow);
                
                // Enhanced connection diagnostics
                setTimeout(() => {
                    console.log('üîç ENHANCED CONNECTION DIAGNOSTICS:');
                    console.log('  üìä Iframe ready state:', iframe.readyState);
                    console.log('  üåê Iframe src:', iframe.src);
                    console.log('  üìè Iframe src length:', iframe.src.length);
                    console.log('  üîó Content window available:', !!iframe.contentWindow);
                    
                    // Test iframe communication
                    try {
                        iframe.contentWindow.postMessage({test: 'ping', timestamp: Date.now()}, '*');
                        console.log('üì§ Test message sent to iframe');
                    } catch (e) {
                        console.error('‚ùå Failed to send test message to iframe:', e);
                    }
                    
                    // Check if iframe is actually loading Social Stream
                    if (iframe.contentWindow) {
                        try {
                            console.log('üîç Iframe location:', iframe.contentWindow.location.href);
                        } catch (e) {
                            console.log('üîí Iframe location blocked (cross-origin) - this is expected');
                        }
                    }
                }, 2000);
                
                // Set up periodic connection check
                const connectionCheck = setInterval(() => {
                    if (iframe.contentWindow) {
                        try {
                            iframe.contentWindow.postMessage({heartbeat: true, timestamp: Date.now()}, '*');
                            console.log('üíì Heartbeat sent to iframe');
                        } catch (e) {
                            console.error('üíî Heartbeat failed:', e);
                            clearInterval(connectionCheck);
                        }
                    } else {
                        console.error('üíî Iframe content window lost');
                        clearInterval(connectionCheck);
                    }
                }, 10000); // Check every 10 seconds
                
                // Try to communicate with iframe after load
                setTimeout(() => {
                    console.log('üîÑ Attempting to ping iframe...');
                    try {
                        iframe.contentWindow.postMessage({type: 'ping', from: 'giveaway'}, '*');
                    } catch (e) {
                        console.error('‚ùå Failed to ping iframe:', e);
                    }
                }, 1000);
            };
            
            iframe.onerror = function(e) {
                console.error('‚ùå Iframe failed to load:', e);
            };
            
            // Track when iframe is added to DOM
            console.log('üìé Adding iframe to document body...');
            document.body.appendChild(iframe);
            console.log('‚úÖ Iframe added to DOM');
            
            // Add heartbeat to show page is active
            let heartbeatCount = 0;
            setInterval(() => {
                heartbeatCount++;
                console.log(`üíì HEARTBEAT #${heartbeatCount} - Page active, listening for messages...`);
                console.log(`üìä Messages received so far: ${messageCount}`);
            }, 10000); // Every 10 seconds
            
            // Listen for messages from the iframe (enhanced debugging version)
            window.addEventListener('message', function(e) {
                messageCount++;
                const timeSinceLoad = (new Date() - debugStartTime) / 1000;
                
                console.log(`üîî === MESSAGE #${messageCount} (${timeSinceLoad.toFixed(1)}s since load) ===`);
                console.log('üì¶ RAW Message event:', e);
                console.log('üì¶ Message data:', e.data);
                console.log('üîç Message source:', e.source === iframe.contentWindow ? 'IFRAME' : 'OTHER');
                console.log('üåç Message origin:', e.origin);
                console.log('üìä Data type:', typeof e.data);
                console.log('üìä Data JSON:', JSON.stringify(e.data, null, 2));
                
                // Enhanced structure analysis
                if (e.data && typeof e.data === 'object') {
                    console.log('üîë Data keys:', Object.keys(e.data));
                    
                    // Check for nested structures
                    if (e.data.dataReceived) {
                        console.log('üì¶ dataReceived structure:', Object.keys(e.data.dataReceived));
                        if (e.data.dataReceived.overlayNinja) {
                            console.log('üéØ overlayNinja found in dataReceived');
                        }
                    }
                    
                    // Check for direct chat properties
                    if (e.data.chatname || e.data.chatmessage || e.data.type) {
                        console.log('üí¨ Direct chat properties found:', {
                            chatname: !!e.data.chatname,
                            chatmessage: !!e.data.chatmessage,
                            type: e.data.type
                        });
                    }
                    
                    // Check for action field
                    if (e.data.action) {
                        console.log('‚ö° Action field:', e.data.action);
                    }
                }
                
                if (e.source != iframe.contentWindow) {
                    console.log('‚ùå Message not from iframe, ignoring');
                    return;
                }
                
                // Use the same simple logic as working sampleoverlay.html
                if (e.data.dataReceived && e.data.dataReceived.overlayNinja) {
                    console.log('‚úÖ FOUND CHAT MESSAGE!', e.data.dataReceived.overlayNinja);
                    processGiveawayMessage(e.data.dataReceived.overlayNinja);
                } else if (e.data.overlayNinja) {
                    console.log('‚úÖ FOUND DIRECT OVERLAY MESSAGE!', e.data.overlayNinja);
                    processGiveawayMessage(e.data.overlayNinja);
                } else if (e.data.chatname || e.data.chatmessage) {
                    console.log('‚úÖ FOUND DIRECT CHAT DATA!', e.data);
                    processGiveawayMessage(e.data);
                } else {
                    console.log('‚ÑπÔ∏è Non-chat message:', e.data);
                }
            });
            
            // Add periodic connection and message status checks
            setTimeout(() => {
                console.log('üìä === 5-SECOND STATUS CHECK ===');
                console.log('üîó Iframe still exists:', !!iframe);
                console.log('üìç Iframe contentWindow:', !!iframe?.contentWindow);
                console.log('üîó Iframe src:', iframe ? iframe.src : 'N/A');
                console.log('üì® Messages received so far:', messageCount);
                console.log('‚è±Ô∏è Time since load:', ((new Date() - debugStartTime) / 1000).toFixed(1) + 's');
                console.log('================================');
            }, 5000);
            
            // Add a longer status check
            setTimeout(() => {
                console.log('üìä === 15-SECOND STATUS CHECK ===');
                console.log('üì® Total messages received:', messageCount);
                console.log('üìà Message rate:', (messageCount / 15).toFixed(2) + ' msg/sec');
                if (messageCount === 0) {
                    console.log('‚ö†Ô∏è NO MESSAGES RECEIVED YET!');
                    console.log('üîç Possible issues:');
                    console.log('  1. Wrong session ID');
                    console.log('  2. No active chat in the session');
                    console.log('  3. WebRTC connection failed');
                    console.log('  4. Iframe blocked by browser');
                }
                console.log('================================');
            }, 15000);
            
            console.log(`üéØ Giveaway connected to Social Stream WebRTC with session: ${roomID}`);
        }
        
        // WebSocket fallback implementation (from sampleoverlay.html)
        var conCon = 1;
        var socketserver = false;
        var serverURL = urlParams.has("localserver") ? "ws://127.0.0.1:3000" : "wss://io.socialstream.ninja";
        
        function setupSocket() {
            console.log('üîå Setting up WebSocket connection to:', serverURL);
            
            socketserver.onclose = function() {
                console.log('üîå WebSocket closed, attempting reconnect...');
                setTimeout(function() {
                    conCon += 1;
                    socketserver = new WebSocket(serverURL);
                    setupSocket();
                }, 100 * conCon);
            };
            
            socketserver.onopen = function() {
                console.log('‚úÖ WebSocket connected successfully!');
                conCon = 1;
                const joinMessage = {"join": roomID, "out": 3, "in": 4};
                console.log('üì§ Sending join message:', joinMessage);
                socketserver.send(JSON.stringify(joinMessage));
            };
            
            socketserver.addEventListener('message', function(event) {
                console.log('üì® WebSocket message received:', event.data);
                if (event.data) {
                    try {
                        var data = JSON.parse(event.data);
                        if (data) {
                            console.log('üéØ WEBSOCKET CHAT MESSAGE:', data);
                            processGiveawayMessage(data);
                        }
                    } catch (error) {
                        console.error("‚ùå Error processing WebSocket message:", error, "Data:", event.data);
                    }
                }
            });
            
            socketserver.onerror = function(error) {
                console.error('‚ùå WebSocket error:', error);
            };
        }
        
        // Enable WebSocket if server parameter is provided or for testing
        if (urlParams.has("server") || urlParams.has("server2") || urlParams.has("websocket")) {
            console.log('üîå WebSocket mode enabled');
            serverURL = urlParams.get("server") || urlParams.get("server2") || serverURL;
            socketserver = new WebSocket(serverURL);
            setupSocket();
        }
        
        // WebSocket fallback debugging function
        function testWebSocketConnection() {
            console.log('üîÑ TESTING WEBSOCKET FALLBACK...');
            const wsUrl = `wss://api.socialstream.ninja/ws?session=${roomID}&password=${password}`;
            console.log('üîó WebSocket URL:', wsUrl);
            
            try {
                const ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    console.log('‚úÖ WebSocket connection opened successfully!');
                    console.log('üì° This means the session ID is valid');
                };
                
                ws.onmessage = function(event) {
                    console.log('üì® WebSocket message received:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üìä Parsed WebSocket data:', data);
                        if (data.chatname && data.chatmessage) {
                            console.log('üéØ FOUND CHAT DATA VIA WEBSOCKET:');
                            console.log('  - chatname:', data.chatname);
                            console.log('  - chatmessage:', data.chatmessage);
                        }
                    } catch (e) {
                        console.log('‚ùå Failed to parse WebSocket data:', e);
                    }
                };
                
                ws.onerror = function(error) {
                    console.log('‚ùå WebSocket error:', error);
                };
                
                ws.onclose = function(event) {
                    console.log('üîå WebSocket closed:', event.code, event.reason);
                };
                
                // Close after 30 seconds
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        console.log('üîå Closing WebSocket test connection');
                        ws.close();
                    }
                }, 30000);
                
            } catch (error) {
                console.log('‚ùå Failed to create WebSocket:', error);
            }
        }
        
        // Add WebSocket test button to page for manual testing
        function addWebSocketTestButton() {
            const button = document.createElement('button');
            button.textContent = 'üîÑ Test WebSocket';
            button.style.position = 'fixed';
            button.style.top = '10px';
            button.style.left = '10px';
            button.style.zIndex = '9999';
            button.style.padding = '10px';
            button.style.backgroundColor = '#2196F3';
            button.style.color = 'white';
            button.style.border = 'none';
            button.style.borderRadius = '5px';
            button.style.cursor = 'pointer';
            button.onclick = testWebSocketConnection;
            document.body.appendChild(button);
            console.log('üîò Added WebSocket test button to page');
        }
        
        // Process incoming chat messages for giveaway entries
        function processGiveawayMessage(data) {
            console.log("üöÄ processGiveawayMessage called with:", data);
            console.log("üîç RAW DATA TYPE:", typeof data);
            console.log("üîç RAW DATA STRUCTURE:", JSON.stringify(data, null, 2));
            
            // Comprehensive data analysis
            console.log("üîç DETAILED DATA BREAKDOWN:");
            console.log("  - chatname:", data.chatname || "‚ùå NOT FOUND");
            console.log("  - chatmessage:", data.chatmessage || "‚ùå NOT FOUND");
            console.log("  - type:", data.type || "‚ùå NOT FOUND");
            console.log("  - All data keys:", Object.keys(data));
            console.log("  - Data length:", Object.keys(data).length);
            
            // Check for nested structures
            if (data.data) {
                console.log("üîç NESTED DATA FOUND:");
                console.log("  - data.data:", data.data);
                console.log("  - data.data keys:", Object.keys(data.data || {}));
            }
            
            // Check for alternative field names
            console.log("üîç ALTERNATIVE FIELD CHECK:");
            console.log("  - username:", data.username || "‚ùå NOT FOUND");
            console.log("  - user:", data.user || "‚ùå NOT FOUND");
            console.log("  - name:", data.name || "‚ùå NOT FOUND");
            console.log("  - message:", data.message || "‚ùå NOT FOUND");
            console.log("  - text:", data.text || "‚ùå NOT FOUND");
            console.log("  - content:", data.content || "‚ùå NOT FOUND");
            
            // Show a visual indicator that a message was received
            const indicator = document.createElement('div');
            indicator.textContent = 'üì® Message received';
            indicator.style.position = 'fixed';
            indicator.style.top = '10px';
            indicator.style.right = '10px';
            indicator.style.backgroundColor = '#4CAF50';
            indicator.style.color = 'white';
            indicator.style.padding = '10px';
            indicator.style.borderRadius = '5px';
            indicator.style.zIndex = '9999';
            document.body.appendChild(indicator);
            
            // Remove the indicator after 2 seconds
            setTimeout(() => {
                indicator.style.opacity = '0';
                indicator.style.transition = 'opacity 0.5s';
                setTimeout(() => indicator.remove(), 500);
            }, 2000);
            
            // Use same validation logic as sampleoverlay.html - more permissive
            if (!data.chatname && !data.chatmessage && !data.hasDonation && !data.donation && !data.contentimg) {
                console.log("No valid message data found:", data);
                return;
            }
            
            // Show warning if missing expected fields but continue processing
            if (!data.chatname || !data.chatmessage) {
                console.log("‚ö†Ô∏è Warning - missing some fields:", {
                    chatname: data.chatname,
                    chatmessage: data.chatmessage,
                    type: data.type
                });
                
                // Show warning indicator but don't return
                const warningIndicator = document.createElement('div');
                warningIndicator.textContent = '‚ö†Ô∏è Partial data: ' + 
                    (!data.chatname ? 'no chatname ' : '') + 
                    (!data.chatmessage ? 'no chatmessage ' : '');
                warningIndicator.style.position = 'fixed';
                warningIndicator.style.top = '60px';
                warningIndicator.style.right = '10px';
                warningIndicator.style.backgroundColor = '#FF9800';
                warningIndicator.style.color = 'white';
                warningIndicator.style.padding = '10px';
                warningIndicator.style.borderRadius = '5px';
                warningIndicator.style.zIndex = '9999';
                document.body.appendChild(warningIndicator);
                
                // Remove the warning indicator after 2 seconds
                setTimeout(() => {
                    warningIndicator.style.opacity = '0';
                    warningIndicator.style.transition = 'opacity 0.5s';
                    setTimeout(() => warningIndicator.remove(), 500);
                }, 2000);
            }
            
            // Handle missing chatname or chatmessage gracefully
            const chatname = data.chatname || 'Unknown User';
            const chatmessage = data.chatmessage || '';
            const platform = data.type || 'unknown';
            
            console.log(`Processing message from ${chatname} (${platform}): "${chatmessage}"`);
            
            // Only check keyword if we have a message
            if (chatmessage) {
                // Check if message contains the current keyword
                const message = chatmessage.toLowerCase().trim();
                const keyword = currentKeyword.toLowerCase();
                
                console.log(`Checking if "${message}" contains keyword "${keyword}"`);
                
                if (message.includes(keyword)) {
                    console.log("Keyword match found!");
                    
                    // Add user to giveaway
                    const entrantId = `${chatname}_${platform}`;
                    
                    // Prevent duplicate entries
                    if (!entrants[entrantId]) {
                        entrants[entrantId] = {
                            name: chatname,
                            platform: platform,
                            timestamp: Date.now(),
                            originalMessage: chatmessage
                        };
                    
                    console.log(`‚úÖ New giveaway entry added: ${chatname} from ${platform}`);
                    updateDisplay();
                    saveState();
                    
                    // Show success indicator
                    const successIndicator = document.createElement('div');
                    successIndicator.textContent = '‚úÖ Added entry: ' + chatname;
                    successIndicator.style.position = 'fixed';
                    successIndicator.style.top = '160px';
                    successIndicator.style.right = '10px';
                    successIndicator.style.backgroundColor = '#2196F3';
                    successIndicator.style.color = 'white';
                    successIndicator.style.padding = '10px';
                    successIndicator.style.borderRadius = '5px';
                    successIndicator.style.zIndex = '9999';
                    document.body.appendChild(successIndicator);
                    
                    // Remove the success indicator after 3 seconds
                    setTimeout(() => {
                        successIndicator.style.opacity = '0';
                        successIndicator.style.transition = 'opacity 0.5s';
                        setTimeout(() => successIndicator.remove(), 500);
                    }, 3000);
                } else {
                    console.log(`‚ùå Duplicate entry prevented: ${data.chatname} from ${data.type}`);
                    
                    // Show duplicate entry indicator
                    const dupIndicator = document.createElement('div');
                    dupIndicator.textContent = 'üîÑ Duplicate entry: ' + data.chatname;
                    dupIndicator.style.position = 'fixed';
                    dupIndicator.style.top = '110px';
                    dupIndicator.style.right = '10px';
                    dupIndicator.style.backgroundColor = '#FF9800';
                    dupIndicator.style.color = 'white';
                    dupIndicator.style.padding = '10px';
                    dupIndicator.style.borderRadius = '5px';
                    dupIndicator.style.zIndex = '9999';
                    document.body.appendChild(dupIndicator);
                    
                    // Remove the duplicate indicator after 2 seconds
                    setTimeout(() => {
                        dupIndicator.style.opacity = '0';
                        dupIndicator.style.transition = 'opacity 0.5s';
                        setTimeout(() => dupIndicator.remove(), 500);
                    }, 2000);
                }
            } else {
                console.log(`‚ùå No keyword match: "${message}" does not contain "${keyword}"`);
            }
        } else {
            console.log("No message content to check for keyword");
        }
    }

        // Check for OBS mode
        if (urlParams.get('obs') === 'true') {
            isOBSMode = true;
            document.body.classList.add('obs-mode');
        }

        // Platform colors
        function getPlatformColor(platform, index) {
            const platformColors = {
                'twitch': '#9146ff',
                'youtube': '#ff0000',
                'facebook': '#1877f2',
                'instagram': '#e4405f',
                'tiktok': '#000000',
                'discord': '#5865f2',
                'kick': '#53fc18'
            };
            return platformColors[platform?.toLowerCase()] || `hsl(${index * 137.5 % 360}, 70%, 60%)`;
        }

        // Preload platform icons
        function preloadPlatformIcons(entrants, callback) {
            const entrantsList = Object.values(entrants);
            const uniquePlatforms = [...new Set(entrantsList.map(e => e.platform).filter(p => p))];
            let loadedCount = 0;
            const totalCount = uniquePlatforms.length;
            
            if (totalCount === 0) {
                callback();
                return;
            }
            
            uniquePlatforms.forEach(platform => {
                if (platformIconCache[platform]) {
                    loadedCount++;
                    if (loadedCount === totalCount) callback();
                    return;
                }
                
                const img = new Image();
                img.onload = function() {
                    platformIconCache[platform] = img;
                    loadedCount++;
                    if (loadedCount === totalCount) callback();
                };
                img.onerror = function() {
                    platformIconCache[platform] = null;
                    loadedCount++;
                    if (loadedCount === totalCount) callback();
                };
                img.src = `./sources/images/${platform.toLowerCase()}.png`;
            });
        }

        // Draw wheel function
        function drawWheel(canvas, entrants) {
            if (!canvas || !entrants) {
                return;
            }
            
            // Ensure canvas size matches its container
            const container = canvas.parentElement;
            if (container) {
                const containerRect = container.getBoundingClientRect();
                if (containerRect.width > 0 && containerRect.height > 0) {
                    canvas.width = Math.min(containerRect.width, containerRect.height);
                    canvas.height = canvas.width;
                }
            }
            
            // Preload platform icons first, then draw
            preloadPlatformIcons(entrants, function() {
                drawWheelWithIcons(canvas, entrants);
            });
        }

        function drawWheelWithIcons(canvas, entrants) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 10;
            
            const entrantsList = Object.values(entrants);
            const segmentAngle = (2 * Math.PI) / entrantsList.length;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (entrantsList.length === 0) {
                // Draw empty wheel
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#ddd';
                ctx.fill();
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Add participants to spin!', centerX, centerY);
                return;
            }
            
            // Draw wheel segments
            entrantsList.forEach((entrant, index) => {
                const startAngle = index * segmentAngle;
                const endAngle = (index + 1) * segmentAngle;
                
                // Get platform-specific color or generate one
                const segmentColor = getPlatformColor(entrant.platform, index);
                
                // Draw segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = segmentColor;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw text and platform badge
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + segmentAngle / 2);
                ctx.textAlign = 'left';
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 2;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                
                const textX = radius * 0.3;
                const maxTextWidth = radius * 0.6;
                const userName = entrant.name || 'Anonymous';
                
                // Truncate text if too long
                let displayText = userName;
                if (ctx.measureText(displayText).width > maxTextWidth) {
                    while (ctx.measureText(displayText + '...').width > maxTextWidth && displayText.length > 1) {
                        displayText = displayText.slice(0, -1);
                    }
                    displayText += '...';
                }
                
                ctx.fillText(displayText, textX, 5);
                
                // Draw platform icon
                if (entrant.platform) {
                    const platformIcon = platformIconCache[entrant.platform];
                    
                    if (platformIcon) {
                        // Draw platform icon from cache
                        const iconSize = 16;
                        const iconX = textX;
                        const iconY = 15;
                        
                        // Draw icon background circle
                        ctx.beginPath();
                        ctx.arc(iconX + iconSize/2, iconY + iconSize/2, iconSize/2 + 2, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Draw platform icon
                        ctx.drawImage(platformIcon, iconX, iconY, iconSize, iconSize);
                    } else {
                        // Fallback to text if icon failed to load or doesn't exist
                        const platformText = entrant.platform.substring(0, 2).toUpperCase();
                        ctx.font = 'bold 10px Arial';
                        ctx.fillStyle = '#000';
                        ctx.fillRect(textX, 15, 20, 12);
                        ctx.fillStyle = '#fff';
                        ctx.fillText(platformText, textX + 2, 25);
                    }
                }
                
                ctx.restore();
            });
        }

        // Spin wheel function
        function spinWheel() {
            const canvas = document.getElementById('wheel-canvas');
            const entrantsList = Object.values(entrants);
            
            if (isSpinning) return;
            if (entrantsList.length === 0) {
                alert('Please add some participants first!');
                return;
            }
            
            isSpinning = true;
            document.getElementById('spin-btn').disabled = true;
            document.getElementById('winner-display').style.display = 'none';
            
            const segmentAngle = 360 / entrantsList.length;
            const winnerIndex = Math.floor(Math.random() * entrantsList.length);
            const targetAngle = (winnerIndex * segmentAngle) + (segmentAngle / 2);
            const totalRotation = 360 * 5 + targetAngle; // 5 full rotations plus target
            
            // Convert to radians for OBS widget
            const targetRotationRadians = (totalRotation * Math.PI) / 180;
            
            // Broadcast spin state to OBS widget
            const spinState = {
                isSpinning: true,
                targetRotation: targetRotationRadians,
                duration: 4000,
                winnerIndex: winnerIndex,
                timestamp: Date.now()
            };
            localStorage.setItem('wheelSpinState', JSON.stringify(spinState));
            
            let currentRotation = 0;
            const duration = 4000; // 4 seconds
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth deceleration
                const easeOut = 1 - Math.pow(1 - progress, 3);
                currentRotation = totalRotation * easeOut;
                
                canvas.style.transform = `rotate(${currentRotation}deg)`;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Animation complete, show winner
                    const winner = entrantsList[winnerIndex];
                    showWinner(winner);
                    isSpinning = false;
                    document.getElementById('spin-btn').disabled = false;
                    
                    // Clear spin state
                    localStorage.removeItem('wheelSpinState');
                }
            }
            
            animate();
        }

        // Show winner
        function showWinner(winner) {
            const winnerDisplay = document.getElementById('winner-display');
            const platformBadge = winner.platform ? 
                `<span class="platform-badge platform-${winner.platform}">${winner.platform.toUpperCase()}</span>` : '';
            
            winnerDisplay.innerHTML = `
                üéâ Winner: <strong>${winner.name}</strong> ${platformBadge}
            `;
            winnerDisplay.style.display = 'block';
            
            // Broadcast winner to OBS widget
            const winnerData = {
                name: winner.name,
                platform: winner.platform,
                timestamp: Date.now()
            };
            localStorage.setItem('wheelWinner', JSON.stringify(winnerData));
            
            // Create confetti effect
            createConfetti();
            
            // Save to localStorage for OBS integration
            saveState();
            
            // Clear winner data after 6 seconds (longer than OBS display)
            setTimeout(() => {
                localStorage.removeItem('wheelWinner');
            }, 6000);
        }

        // Create confetti effect
        function createConfetti() {
            const confettiCount = 100;
            const colors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590'];
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.top = '0';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.opacity = '1';
                confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                
                const size = Math.random() * 10 + 5;
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size}px`;
                
                const shapes = ['circle', 'square', 'triangle'];
                const shape = shapes[Math.floor(Math.random() * shapes.length)];
                if (shape === 'circle') {
                    confetti.style.borderRadius = '50%';
                } else if (shape === 'triangle') {
                    confetti.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                }
                
                document.body.appendChild(confetti);
                
                const animation = confetti.animate([
                    { transform: `translate(0, 0) rotate(0)`, opacity: 1 },
                    { transform: `translate(${Math.random() * 100 - 50}px, ${Math.random() * 500 + 200}px) rotate(${Math.random() * 360}deg)`, top: '100vh', opacity: 0 }
                ], {
                    duration: Math.random() * 3000 + 2000,
                    easing: 'cubic-bezier(0.1, 0.4, 0.3, 1)'
                });
                
                animation.onfinish = () => confetti.remove();
            }
        }

        // Add entrant
        function addEntrant() {
            const nameInput = document.getElementById('entrant-name');
            const platformSelect = document.getElementById('platform-select');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('Please enter a participant name');
                return;
            }
            
            const id = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            entrants[id] = {
                name: name,
                platform: platformSelect.value
            };
            
            nameInput.value = '';
            updateDisplay();
            saveState();
        }

        // Clear all entrants
        function clearEntrants() {
            if (Object.keys(entrants).length === 0) return;
            
            if (confirm('Are you sure you want to clear all participants?')) {
                entrants = {};
                updateDisplay();
                saveState();
            }
        }

        // Add test data
        function addTestData() {
            const testEntrants = [
                { name: 'Alice', platform: 'twitch' },
                { name: 'Bob', platform: 'youtube' },
                { name: 'Charlie', platform: 'facebook' },
                { name: 'Diana', platform: 'instagram' },
                { name: 'Eve', platform: 'tiktok' },
                { name: 'Frank', platform: 'discord' },
                { name: 'Grace', platform: 'kick' }
            ];
            
            testEntrants.forEach((entrant, index) => {
                const id = 'test_' + Date.now() + '_' + index;
                entrants[id] = entrant;
            });
            
            updateDisplay();
            saveState();
        }

        // Remove entrant
        function removeEntrant(id) {
            delete entrants[id];
            updateDisplay();
            saveState();
        }

        // Update display
        function updateDisplay() {
            const canvas = document.getElementById('wheel-canvas');
            const entrantsContainer = document.getElementById('entrants-container');
            const entrantCount = document.getElementById('entrant-count');
            
            // Update wheel
            drawWheel(canvas, entrants);
            
            // Update entrants list
            entrantCount.textContent = Object.keys(entrants).length;
            entrantsContainer.innerHTML = '';
            
            Object.entries(entrants).forEach(([id, entrant]) => {
                const entrantDiv = document.createElement('div');
                entrantDiv.className = 'entrant-item';
                entrantDiv.innerHTML = `
                    <span>
                        ${entrant.name}
                        <span class="platform-badge platform-${entrant.platform}">${entrant.platform.toUpperCase()}</span>
                    </span>
                    <button onclick="removeEntrant('${id}')" style="background: #ff4444; color: white; border: none; border-radius: 3px; padding: 4px 8px; cursor: pointer;">Remove</button>
                `;
                entrantsContainer.appendChild(entrantDiv);
            });
        }

        // Save state to localStorage for project integration
        function saveState() {
            const state = {
                entrants: entrants,
                timestamp: Date.now()
            };
            localStorage.setItem('giveawayWheelState', JSON.stringify(state));
            
            // Broadcast to other instances (OBS integration)
            localStorage.setItem('giveawayWheelUpdate', JSON.stringify({
                timestamp: Date.now(),
                data: state
            }));
            setTimeout(() => {
                localStorage.removeItem('giveawayWheelUpdate');
            }, 100);
        }

        // Load state from localStorage
        function loadState() {
            try {
                const savedState = localStorage.getItem('giveawayWheelState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    if (state.entrants) {
                        entrants = state.entrants;
                        updateDisplay();
                    }
                }
            } catch (error) {
                console.error('Error loading state:', error);
            }
        }

        // Listen for state updates from other instances
        window.addEventListener('storage', function(e) {
            if (e.key === 'giveawayWheelUpdate') {
                try {
                    const update = JSON.parse(e.newValue);
                    if (update && update.data && update.data.entrants) {
                        entrants = update.data.entrants;
                        updateDisplay();
                    }
                } catch (error) {
                    console.error('Error processing state update:', error);
                }
            }
        });

        // User-controlled keyword system
        function setKeyword() {
            const keywordInput = document.getElementById('keyword-input');
            const newKeyword = keywordInput.value.trim().toUpperCase();
            
            if (newKeyword && newKeyword.length > 0) {
                currentKeyword = newKeyword;
                document.getElementById('current-keyword').textContent = currentKeyword;
                
                // Save keyword for OBS widget
                localStorage.setItem('giveaway_keyword', currentKeyword);
                localStorage.setItem('giveaway_keyword_timestamp', Date.now().toString());
                
                // Clear input
                keywordInput.value = '';
                
                console.log(`Keyword set to: ${currentKeyword}`);
                updateGiveawayState();
            }
        }

        function loadKeyword() {
            const savedKeyword = localStorage.getItem('giveaway_keyword');
            if (savedKeyword) {
                currentKeyword = savedKeyword;
                document.getElementById('current-keyword').textContent = currentKeyword;
            }
        }

        function updateGiveawayState() {
            const state = {
                participants: Object.values(entrants).map(entrant => ({
                    name: entrant.name,
                    platform: entrant.platform,
                    timestamp: Date.now(),
                    id: Date.now() + Math.random()
                })),
                title: 'Giveaway Entries',
                keyword: currentKeyword,
                timestamp: Date.now()
            };
            
            localStorage.setItem('giveaway_state', JSON.stringify(state));
        }

        function openOBSWidget() {
            const obsUrl = window.location.origin + window.location.pathname.replace('giveaway.html', 'giveaway-obs-entries.html');
            window.open(obsUrl, '_blank', 'width=800,height=600');
        }

        // Simulate chat message processing for keyword entries
        // Clear all entries function
        function clearAllEntries() {
            entrants = {};
            updateDisplay();
            saveState();
            updateGiveawayState();
            console.log('All entries cleared');
        }

        // Manual test function to simulate Social Stream messages
        function testSocialStreamMessage() {
            const testPlatforms = ['twitch', 'youtube', 'discord', 'kick', 'facebook'];
            const testUsers = ['TestUser1', 'TestUser2', 'StreamViewer', 'ChatFan', 'GiveawayLover'];
            
            const randomUser = testUsers[Math.floor(Math.random() * testUsers.length)] + Date.now();
            const randomPlatform = testPlatforms[Math.floor(Math.random() * testPlatforms.length)];
            
            // Simulate a Social Stream message structure
            const testMessage = {
                chatname: randomUser,
                chatmessage: `${currentKeyword} please! I want to win!`,
                type: randomPlatform,
                id: Date.now(),
                timestamp: Date.now()
            };
            
            console.log("Simulating Social Stream message:", testMessage);
            processGiveawayMessage(testMessage);
        }
        
        // Test WebRTC connection
        function testWebRTCConnection() {
            console.log('=== WEBRTC CONNECTION TEST ===');
            console.log('Iframe exists:', !!iframe);
            if (iframe) {
                console.log('Iframe src:', iframe.src);
                console.log('Iframe loaded:', iframe.contentDocument !== null);
                console.log('Iframe ready state:', iframe.readyState);
                
                // Try to send a test message to the iframe
                try {
                    iframe.contentWindow.postMessage({test: 'ping'}, '*');
                    console.log('Test message sent to iframe');
                } catch (error) {
                    console.error('Failed to send test message:', error);
                }
            } else {
                console.log('No iframe found!');
            }
            console.log('==============================');
        }
        
        // Add keyboard shortcuts for testing
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 't') {
                e.preventDefault();
                testSocialStreamMessage();
                console.log('Simulated Social Stream message (Ctrl+T)');
            } else if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                clearAllEntries();
                console.log('Cleared all entries (Ctrl+C)');
            } else if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                testWebRTCConnection();
            }
        });

        // Handle Enter key in name input
        document.getElementById('entrant-name').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addEntrant();
            }
        });
        
        // Handle Enter key in keyword input
        document.getElementById('keyword-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                setKeyword();
            }
        });

        // Override saveState to also update giveaway state
        const originalSaveState = saveState;
        saveState = function() {
            originalSaveState();
            updateGiveawayState();
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadState();
            loadKeyword();
            updateDisplay();
            updateGiveawayState();
            
            // Add WebSocket test button for debugging
            addWebSocketTestButton();
            
            // Connect to Social Stream WebRTC if session ID is provided
            setupWebRTCConnection();
        });
    </script>
</body>
</html>
