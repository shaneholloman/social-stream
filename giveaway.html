<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giveaway Wheel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    animation: {
                        'spin-slow': 'spin 3s linear infinite',
                        'spin-fast': 'spin 0.5s linear infinite',
                        'bounce-gentle': 'bounce 2s infinite',
                        'pulse-slow': 'pulse 3s infinite',
                        'wheel-spin': 'wheel-spin 4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards',
                    },
                    keyframes: {
                        'wheel-spin': {
                            '0%': { transform: 'rotate(0deg)' },
                            '100%': { transform: 'rotate(1800deg)' }
                        }
                    },
                    colors: {
                        'wheel-primary': '#667eea',
                        'wheel-secondary': '#764ba2',
                    }
                }
            }
        }
    </script>
    <style>
        /* Keep essential wheel-specific styles that can't be easily replicated with Tailwind */
        .wheel-pointer {
            position: absolute;
            top: 50%;
            right: -15px;
            width: 0;
            height: 0;
            border-left: 20px solid #ef4444;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            z-index: 10;
            transform: translateY(-50%);
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
        }

        .wheel-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: #374151;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            border: 3px solid #ffffff;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        /* Minimal custom styles for elements that can't be easily replicated with Tailwind */

        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #f94144;
            z-index: 1000;
            pointer-events: none;
        }

        /* OBS Mode Styles */
        .obs-mode {
            background: transparent !important;
            padding: 0 !important;
        }

        .obs-mode .container {
            background: transparent;
            box-shadow: none;
        }

        .obs-mode h1 {
            display: none;
        }

        .obs-mode .controls {
            display: none;
        }

        .obs-mode .entrants-list {
            display: none;
        }

        @media (max-width: 768px) {
            .wheel-container {
                width: 300px;
                height: 300px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .input-group {
                flex-direction: column;
            }
            
            input[type="text"] {
                min-width: 250px;
            }
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-wheel-primary via-purple-600 to-wheel-secondary flex flex-col items-center justify-center text-white font-sans">
    <div class="text-center max-w-4xl w-full px-6 py-8">
        <h1 class="text-5xl md:text-6xl font-bold mb-8 text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 via-pink-500 to-purple-600 drop-shadow-lg animate-pulse-slow">
            üéØ Giveaway Wheel
        </h1>
        
        <div class="relative w-96 h-96 md:w-[400px] md:h-[400px] mx-auto my-8 flex items-center justify-center group">
            <div class="wheel-pointer transition-all duration-300 "></div>
            <canvas id="wheel-canvas" class="rounded-full shadow-2xl transition-transform duration-100 ease-out hover:scale-105" width="400" height="400"></canvas>
            <div class="wheel-center transition-all duration-300 "></div>
        </div>

        <div class="hidden bg-gradient-to-r from-yellow-400 via-yellow-500 to-amber-500 text-gray-900 p-6 rounded-2xl my-6 text-2xl font-bold shadow-2xl border-4 border-yellow-300 animate-bounce-gentle" id="winner-display"></div>

        <div class="space-y-6 mt-8">
            <div class="bg-white/10 backdrop-blur-md p-6 rounded-2xl border border-white/20 shadow-xl">
                <h3 class="text-2xl font-bold mb-4 text-center">üîë Entry Keyword</h3>
                <div class="text-2xl text-yellow-400 font-bold text-center my-4">
                    Current Keyword: <span class="bg-yellow-400 text-gray-900 px-3 py-1 rounded-lg" id="current-keyword">ENTER</span>
                </div>
                <div class="text-sm text-gray-300 text-center mb-4">
                    Viewers type this keyword in chat to enter the giveaway
                </div>
                <div class="flex flex-col sm:flex-row gap-3 items-center justify-center mb-4">
                    <input type="text" id="keyword-input" placeholder="Enter new keyword..." 
                           class="px-4 py-3 rounded-lg border-2 border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all duration-200 text-gray-900 font-medium min-w-0 flex-1">
                    <button onclick="setKeyword()" 
                            class="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                        Set Keyword
                    </button>
                </div>
                <button onclick="openOBSWidget()" 
                        class="w-full px-6 py-3 bg-gradient-to-r from-purple-500 to-purple-600 hover:from-purple-600 hover:to-purple-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    üì∫ Open OBS Widget
                </button>
            </div>

            <div class="flex flex-col sm:flex-row gap-3 items-center justify-center">
                <input type="text" id="entrant-name" placeholder="Enter participant name" 
                       class="px-4 py-3 rounded-lg border-2 border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all duration-200 text-gray-900 font-medium min-w-0 flex-1">
                <select id="platform-select" 
                        class="px-4 py-3 rounded-lg border-2 border-gray-300 focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-all duration-200 text-gray-900 font-medium">
                    <option value="twitch">Twitch</option>
                    <option value="youtube">YouTube</option>
                    <option value="facebook">Facebook</option>
                    <option value="instagram">Instagram</option>
                    <option value="tiktok">TikTok</option>
                    <option value="discord">Discord</option>
                    <option value="kick">Kick</option>
                </select>
                <button onclick="addEntrant()" 
                        class="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    Add Participant
                </button>
            </div>
            
            <div class="flex flex-wrap gap-3 items-center justify-center">
                <button onclick="spinWheel()" id="spin-btn" 
                        class="px-8 py-4 bg-gradient-to-r from-red-500 via-pink-500 to-red-600 hover:from-red-600 hover:via-pink-600 hover:to-red-700 text-white font-bold rounded-xl transition-all duration-200 transform hover:scale-110 hover:shadow-2xl text-lg motion-safe:hover:animate-pulse">
                    üéØ Spin the Wheel!
                </button>
                <button onclick="clearEntrants()" 
                        class="px-6 py-3 bg-gradient-to-r from-green-500 to-green-600 hover:from-green-600 hover:to-green-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    Clear All
                </button>
                <button onclick="addTestData()" 
                        class="px-6 py-3 bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    Add Test Data
                </button>
                <button onclick="clearAllEntries()" 
                        class="px-6 py-3 bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white font-bold rounded-lg transition-all duration-200 transform hover:scale-105 hover:shadow-lg">
                    üóëÔ∏è Clear All Entries
                </button>
            </div>
        </div>

        <div class="bg-white/10 backdrop-blur-md p-6 rounded-2xl border border-white/20 shadow-xl mt-8">
            <h3 class="text-2xl font-bold mb-4 text-center">
                Participants (<span class="text-yellow-400" id="entrant-count">0</span>)
            </h3>
            <div id="entrants-container" class="space-y-2 max-h-64 overflow-y-auto scrollbar-thin scrollbar-thumb-white/20 scrollbar-track-transparent"></div>
        </div>
    </div>

    <script>
        // üêõ DEBUGGING VARIABLES
        let messageCount = 0;
        let debugStartTime = new Date();
        
        console.log('üéØ GIVEAWAY PAGE LOADED');
        console.log('‚è∞ Load time:', debugStartTime.toISOString());
        console.log('üåê Page URL:', window.location.href);
        console.log('üì± User Agent:', navigator.userAgent);
        console.log('üîß Console debugging enabled');
        
        // Global state
        let entrants = {};
        let isSpinning = false;
        let isOBSMode = false;
        let currentKeyword = 'ENTER';
        
        // Social Stream WebRTC integration
        let iframe = null;
        let roomID = "test";
        let password = "false";
        
        // Get session ID and password from URL parameters
        console.log('üîç PARSING URL PARAMETERS...');
        const urlParams = new URLSearchParams(window.location.search);
        console.log('üìã All URL params:', Array.from(urlParams.entries()));
        
        if (urlParams.has("session")) {
            roomID = urlParams.get("session");
            console.log('‚úÖ Found session parameter:', roomID);
        } else if (urlParams.has("s")) {
            roomID = urlParams.get("s");
            console.log('‚úÖ Found s parameter:', roomID);
        } else if (urlParams.has("id")) {
            roomID = urlParams.get("id");
            console.log('‚úÖ Found id parameter:', roomID);
        } else {
            console.log('‚ùå No session parameter found! Using default:', roomID);
            console.log('üí° Add ?session=YOUR_SESSION_ID to the URL to connect');
        }
        
        if (urlParams.has("password")) {
            password = urlParams.get("password") || "false";
            console.log('üîë Found password parameter:', password);
        } else {
            console.log('üîì No password parameter found, using default:', password);
        }
        
        console.log('üéØ Final connection parameters:');
        console.log('  üìã Room ID:', roomID);
        console.log('  üîë Password:', password);

        // Platform icon cache
        let platformIconCache = {};
        
        // WebRTC iframe setup for Social Stream integration
        function setupWebRTCConnection() {
            if (!roomID || roomID === "test") {
                console.log("No session ID provided. Add ?session=YOUR_SESSION_ID to URL to connect to Social Stream");
                return;
            }
            
            console.log('üöÄ STARTING WEBRTC CONNECTION SETUP...');
            console.log('üìã Session ID:', roomID);
            console.log('üîë Password:', password);
            console.log('üåê Current URL:', window.location.href);
            
            // Create hidden iframe for WebRTC connection
            iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.allow = "midi;geolocation;microphone;"; // microphone needed for Safari WebRTC P2P connections
            iframe.connectedPeers = {};
            
            // Connect as a view-only client to receive chat messages
            iframe.src = "https://vdo.socialstream.ninja/?ln&salt=vdo.ninja&password="+password+"&push&label=dock&vd=0&ad=0&novideo&noaudio&autostart&cleanoutput&room="+roomID;
            
            console.log('üîó Iframe URL:', iframe.src);
            console.log('üìè URL Length:', iframe.src.length);
            
            // Add detailed load event listeners
            iframe.onload = function() {
                console.log('‚úÖ Iframe loaded successfully!');
                console.log('üìç Iframe contentWindow:', !!iframe.contentWindow);
                
                // Enhanced connection diagnostics
                setTimeout(() => {
                    console.log('üîç ENHANCED CONNECTION DIAGNOSTICS:');
                    console.log('  üìä Iframe ready state:', iframe.readyState);
                    console.log('  üåê Iframe src:', iframe.src);
                    console.log('  üìè Iframe src length:', iframe.src.length);
                    console.log('  üîó Content window available:', !!iframe.contentWindow);
                    
                    // Test iframe communication
                    try {
                        iframe.contentWindow.postMessage({test: 'ping', timestamp: Date.now()}, '*');
                        console.log('üì§ Test message sent to iframe');
                    } catch (e) {
                        console.error('‚ùå Failed to send test message to iframe:', e);
                    }
                    
                    // Check if iframe is actually loading Social Stream
                    if (iframe.contentWindow) {
                        try {
                            console.log('üîç Iframe location:', iframe.contentWindow.location.href);
                        } catch (e) {
                            console.log('üîí Iframe location blocked (cross-origin) - this is expected');
                        }
                    }
                }, 2000);
                
                // Set up periodic connection check
                const connectionCheck = setInterval(() => {
                    if (iframe.contentWindow) {
                        try {
                            iframe.contentWindow.postMessage({heartbeat: true, timestamp: Date.now()}, '*');
                            console.log('üíì Heartbeat sent to iframe');
                        } catch (e) {
                            console.error('üíî Heartbeat failed:', e);
                            clearInterval(connectionCheck);
                        }
                    } else {
                        console.error('üíî Iframe content window lost');
                        clearInterval(connectionCheck);
                    }
                }, 10000); // Check every 10 seconds
                
                // Try to communicate with iframe after load
                setTimeout(() => {
                    console.log('üîÑ Attempting to ping iframe...');
                    try {
                        iframe.contentWindow.postMessage({type: 'ping', from: 'giveaway'}, '*');
                    } catch (e) {
                        console.error('‚ùå Failed to ping iframe:', e);
                    }
                }, 1000);
            };
            
            iframe.onerror = function(e) {
                console.error('‚ùå Iframe failed to load:', e);
            };
            
            // Track when iframe is added to DOM
            console.log('üìé Adding iframe to document body...');
            document.body.appendChild(iframe);
            console.log('‚úÖ Iframe added to DOM');
            
            // Add heartbeat to show page is active
            let heartbeatCount = 0;
            setInterval(() => {
                heartbeatCount++;
                console.log(`üíì HEARTBEAT #${heartbeatCount} - Page active, listening for messages...`);
                console.log(`üìä Messages received so far: ${messageCount}`);
            }, 10000); // Every 10 seconds
            
            // Listen for messages from the iframe (enhanced debugging version)
            window.addEventListener('message', function(e) {
                messageCount++;
                const timeSinceLoad = (new Date() - debugStartTime) / 1000;
                
                console.log(`üîî === MESSAGE #${messageCount} (${timeSinceLoad.toFixed(1)}s since load) ===`);
                console.log('üì¶ RAW Message event:', e);
                console.log('üì¶ Message data:', e.data);
                console.log('üîç Message source:', e.source === iframe.contentWindow ? 'IFRAME' : 'OTHER');
                console.log('üåç Message origin:', e.origin);
                console.log('üìä Data type:', typeof e.data);
                console.log('üìä Data JSON:', JSON.stringify(e.data, null, 2));
                
                // Enhanced structure analysis
                if (e.data && typeof e.data === 'object') {
                    console.log('üîë Data keys:', Object.keys(e.data));
                    
                    // Check for nested structures
                    if (e.data.dataReceived) {
                        console.log('üì¶ dataReceived structure:', Object.keys(e.data.dataReceived));
                        if (e.data.dataReceived.overlayNinja) {
                            console.log('üéØ overlayNinja found in dataReceived');
                        }
                    }
                    
                    // Check for direct chat properties
                    if (e.data.chatname || e.data.chatmessage || e.data.type) {
                        console.log('üí¨ Direct chat properties found:', {
                            chatname: !!e.data.chatname,
                            chatmessage: !!e.data.chatmessage,
                            type: e.data.type
                        });
                    }
                    
                    // Check for action field
                    if (e.data.action) {
                        console.log('‚ö° Action field:', e.data.action);
                    }
                }
                
                if (e.source != iframe.contentWindow) {
                    console.log('‚ùå Message not from iframe, ignoring');
                    return;
                }
                
                // Use the same simple logic as working sampleoverlay.html
                if (e.data.dataReceived && e.data.dataReceived.overlayNinja) {
                    console.log('‚úÖ FOUND CHAT MESSAGE!', e.data.dataReceived.overlayNinja);
                    processGiveawayMessage(e.data.dataReceived.overlayNinja);
                } else if (e.data.overlayNinja) {
                    console.log('‚úÖ FOUND DIRECT OVERLAY MESSAGE!', e.data.overlayNinja);
                    processGiveawayMessage(e.data.overlayNinja);
                } else if (e.data.chatname || e.data.chatmessage) {
                    console.log('‚úÖ FOUND DIRECT CHAT DATA!', e.data);
                    processGiveawayMessage(e.data);
                } else {
                    console.log('‚ÑπÔ∏è Non-chat message:', e.data);
                }
            });
            
            // Add periodic connection and message status checks
            setTimeout(() => {
                console.log('üìä === 5-SECOND STATUS CHECK ===');
                console.log('üîó Iframe still exists:', !!iframe);
                console.log('üìç Iframe contentWindow:', !!iframe?.contentWindow);
                console.log('üîó Iframe src:', iframe ? iframe.src : 'N/A');
                console.log('üì® Messages received so far:', messageCount);
                console.log('‚è±Ô∏è Time since load:', ((new Date() - debugStartTime) / 1000).toFixed(1) + 's');
                console.log('================================');
            }, 5000);
            
            // Add a longer status check
            setTimeout(() => {
                console.log('üìä === 15-SECOND STATUS CHECK ===');
                console.log('üì® Total messages received:', messageCount);
                console.log('üìà Message rate:', (messageCount / 15).toFixed(2) + ' msg/sec');
                if (messageCount === 0) {
                    console.log('‚ö†Ô∏è NO MESSAGES RECEIVED YET!');
                    console.log('üîç Possible issues:');
                    console.log('  1. Wrong session ID');
                    console.log('  2. No active chat in the session');
                    console.log('  3. WebRTC connection failed');
                    console.log('  4. Iframe blocked by browser');
                }
                console.log('================================');
            }, 15000);
            
            console.log(`üéØ Giveaway connected to Social Stream WebRTC with session: ${roomID}`);
        }
        
        // WebSocket fallback implementation (from sampleoverlay.html)
        var conCon = 1;
        var socketserver = false;
        var serverURL = urlParams.has("localserver") ? "ws://127.0.0.1:3000" : "wss://io.socialstream.ninja";
        
        function setupSocket() {
            console.log('üîå Setting up WebSocket connection to:', serverURL);
            
            socketserver.onclose = function() {
                console.log('üîå WebSocket closed, attempting reconnect...');
                setTimeout(function() {
                    conCon += 1;
                    socketserver = new WebSocket(serverURL);
                    setupSocket();
                }, 100 * conCon);
            };
            
            socketserver.onopen = function() {
                console.log('‚úÖ WebSocket connected successfully!');
                conCon = 1;
                const joinMessage = {"join": roomID, "out": 3, "in": 4};
                console.log('üì§ Sending join message:', joinMessage);
                socketserver.send(JSON.stringify(joinMessage));
            };
            
            socketserver.addEventListener('message', function(event) {
                console.log('üì® WebSocket message received:', event.data);
                if (event.data) {
                    try {
                        var data = JSON.parse(event.data);
                        if (data) {
                            console.log('üéØ WEBSOCKET CHAT MESSAGE:', data);
                            processGiveawayMessage(data);
                        }
                    } catch (error) {
                        console.error("‚ùå Error processing WebSocket message:", error, "Data:", event.data);
                    }
                }
            });
            
            socketserver.onerror = function(error) {
                console.error('‚ùå WebSocket error:', error);
            };
        }
        
        // Enable WebSocket if server parameter is provided or for testing
        if (urlParams.has("server") || urlParams.has("server2") || urlParams.has("websocket")) {
            console.log('üîå WebSocket mode enabled');
            serverURL = urlParams.get("server") || urlParams.get("server2") || serverURL;
            socketserver = new WebSocket(serverURL);
            setupSocket();
        }
        
        // WebSocket fallback debugging function
        function testWebSocketConnection() {
            console.log('üîÑ TESTING WEBSOCKET FALLBACK...');
            const wsUrl = `wss://api.socialstream.ninja/ws?session=${roomID}&password=${password}`;
            console.log('üîó WebSocket URL:', wsUrl);
            
            try {
                const ws = new WebSocket(wsUrl);
                
                ws.onopen = function() {
                    console.log('‚úÖ WebSocket connection opened successfully!');
                    console.log('üì° This means the session ID is valid');
                };
                
                ws.onmessage = function(event) {
                    console.log('üì® WebSocket message received:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üìä Parsed WebSocket data:', data);
                        if (data.chatname && data.chatmessage) {
                            console.log('üéØ FOUND CHAT DATA VIA WEBSOCKET:');
                            console.log('  - chatname:', data.chatname);
                            console.log('  - chatmessage:', data.chatmessage);
                        }
                    } catch (e) {
                        console.log('‚ùå Failed to parse WebSocket data:', e);
                    }
                };
                
                ws.onerror = function(error) {
                    console.log('‚ùå WebSocket error:', error);
                };
                
                ws.onclose = function(event) {
                    console.log('üîå WebSocket closed:', event.code, event.reason);
                };
                
                // Close after 30 seconds
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        console.log('üîå Closing WebSocket test connection');
                        ws.close();
                    }
                }, 30000);
                
            } catch (error) {
                console.log('‚ùå Failed to create WebSocket:', error);
            }
        }
        
        // Add WebSocket test button to page for manual testing
        function addWebSocketTestButton() {
            const button = document.createElement('button');
            button.textContent = 'üîÑ Test WebSocket';
            button.style.position = 'fixed';
            button.style.top = '10px';
            button.style.left = '10px';
            button.style.zIndex = '9999';
            button.style.padding = '10px';
            button.style.backgroundColor = '#2196F3';
            button.style.color = 'white';
            button.style.border = 'none';
            button.style.borderRadius = '5px';
            button.style.cursor = 'pointer';
            button.onclick = testWebSocketConnection;
            document.body.appendChild(button);
            console.log('üîò Added WebSocket test button to page');
        }
        
        // Process incoming chat messages for giveaway entries
        function processGiveawayMessage(data) {
            console.log("üöÄ processGiveawayMessage called with:", data);
            console.log("üîç RAW DATA TYPE:", typeof data);
            console.log("üîç RAW DATA STRUCTURE:", JSON.stringify(data, null, 2));
            
            // Comprehensive data analysis
            console.log("üîç DETAILED DATA BREAKDOWN:");
            console.log("  - chatname:", data.chatname || "‚ùå NOT FOUND");
            console.log("  - chatmessage:", data.chatmessage || "‚ùå NOT FOUND");
            console.log("  - type:", data.type || "‚ùå NOT FOUND");
            console.log("  - All data keys:", Object.keys(data));
            console.log("  - Data length:", Object.keys(data).length);
            
            // Check for nested structures
            if (data.data) {
                console.log("üîç NESTED DATA FOUND:");
                console.log("  - data.data:", data.data);
                console.log("  - data.data keys:", Object.keys(data.data || {}));
            }
            
            // Check for alternative field names
            console.log("üîç ALTERNATIVE FIELD CHECK:");
            console.log("  - username:", data.username || "‚ùå NOT FOUND");
            console.log("  - user:", data.user || "‚ùå NOT FOUND");
            console.log("  - name:", data.name || "‚ùå NOT FOUND");
            console.log("  - message:", data.message || "‚ùå NOT FOUND");
            console.log("  - text:", data.text || "‚ùå NOT FOUND");
            console.log("  - content:", data.content || "‚ùå NOT FOUND");
            
            // Show a visual indicator that a message was received
            const indicator = document.createElement('div');
            indicator.textContent = 'üì® Message received';
            indicator.style.position = 'fixed';
            indicator.style.top = '10px';
            indicator.style.right = '10px';
            indicator.style.backgroundColor = '#4CAF50';
            indicator.style.color = 'white';
            indicator.style.padding = '10px';
            indicator.style.borderRadius = '5px';
            indicator.style.zIndex = '9999';
            document.body.appendChild(indicator);
            
            // Remove the indicator after 2 seconds
            setTimeout(() => {
                indicator.style.opacity = '0';
                indicator.style.transition = 'opacity 0.5s';
                setTimeout(() => indicator.remove(), 500);
            }, 2000);
            
            // Use same validation logic as sampleoverlay.html - more permissive
            if (!data.chatname && !data.chatmessage && !data.hasDonation && !data.donation && !data.contentimg) {
                console.log("No valid message data found:", data);
                return;
            }
            
            // Show warning if missing expected fields but continue processing
            if (!data.chatname || !data.chatmessage) {
                console.log("‚ö†Ô∏è Warning - missing some fields:", {
                    chatname: data.chatname,
                    chatmessage: data.chatmessage,
                    type: data.type
                });
                
                // Show warning indicator but don't return
                const warningIndicator = document.createElement('div');
                warningIndicator.textContent = '‚ö†Ô∏è Partial data: ' + 
                    (!data.chatname ? 'no chatname ' : '') + 
                    (!data.chatmessage ? 'no chatmessage ' : '');
                warningIndicator.style.position = 'fixed';
                warningIndicator.style.top = '60px';
                warningIndicator.style.right = '10px';
                warningIndicator.style.backgroundColor = '#FF9800';
                warningIndicator.style.color = 'white';
                warningIndicator.style.padding = '10px';
                warningIndicator.style.borderRadius = '5px';
                warningIndicator.style.zIndex = '9999';
                document.body.appendChild(warningIndicator);
                
                // Remove the warning indicator after 2 seconds
                setTimeout(() => {
                    warningIndicator.style.opacity = '0';
                    warningIndicator.style.transition = 'opacity 0.5s';
                    setTimeout(() => warningIndicator.remove(), 500);
                }, 2000);
            }
            
            // Handle missing chatname or chatmessage gracefully
            const chatname = data.chatname || 'Unknown User';
            const chatmessage = data.chatmessage || '';
            const platform = data.type || 'unknown';
            
            console.log(`Processing message from ${chatname} (${platform}): "${chatmessage}"`);
            
            // Only check keyword if we have a message
            if (chatmessage) {
                // Check if message contains the current keyword
                const message = chatmessage.toLowerCase().trim();
                const keyword = currentKeyword.toLowerCase();
                
                console.log(`Checking if "${message}" contains keyword "${keyword}"`);
                
                if (message.includes(keyword)) {
                    console.log("Keyword match found!");
                    
                    // Add user to giveaway
                    const entrantId = `${chatname}_${platform}`;
                    
                    // Prevent duplicate entries
                    if (!entrants[entrantId]) {
                        entrants[entrantId] = {
                            name: chatname,
                            platform: platform,
                            timestamp: Date.now(),
                            originalMessage: chatmessage
                        };
                    
                    console.log(`‚úÖ New giveaway entry added: ${chatname} from ${platform}`);
                    updateDisplay();
                    saveState();
                    
                    // Show success indicator
                    const successIndicator = document.createElement('div');
                    successIndicator.textContent = '‚úÖ Added entry: ' + chatname;
                    successIndicator.style.position = 'fixed';
                    successIndicator.style.top = '160px';
                    successIndicator.style.right = '10px';
                    successIndicator.style.backgroundColor = '#2196F3';
                    successIndicator.style.color = 'white';
                    successIndicator.style.padding = '10px';
                    successIndicator.style.borderRadius = '5px';
                    successIndicator.style.zIndex = '9999';
                    document.body.appendChild(successIndicator);
                    
                    // Remove the success indicator after 3 seconds
                    setTimeout(() => {
                        successIndicator.style.opacity = '0';
                        successIndicator.style.transition = 'opacity 0.5s';
                        setTimeout(() => successIndicator.remove(), 500);
                    }, 3000);
                } else {
                    console.log(`‚ùå Duplicate entry prevented: ${data.chatname} from ${data.type}`);
                    
                    // Show duplicate entry indicator
                    const dupIndicator = document.createElement('div');
                    dupIndicator.textContent = 'üîÑ Duplicate entry: ' + data.chatname;
                    dupIndicator.style.position = 'fixed';
                    dupIndicator.style.top = '110px';
                    dupIndicator.style.right = '10px';
                    dupIndicator.style.backgroundColor = '#FF9800';
                    dupIndicator.style.color = 'white';
                    dupIndicator.style.padding = '10px';
                    dupIndicator.style.borderRadius = '5px';
                    dupIndicator.style.zIndex = '9999';
                    document.body.appendChild(dupIndicator);
                    
                    // Remove the duplicate indicator after 2 seconds
                    setTimeout(() => {
                        dupIndicator.style.opacity = '0';
                        dupIndicator.style.transition = 'opacity 0.5s';
                        setTimeout(() => dupIndicator.remove(), 500);
                    }, 2000);
                }
            } else {
                console.log(`‚ùå No keyword match: "${message}" does not contain "${keyword}"`);
            }
        } else {
            console.log("No message content to check for keyword");
        }
    }

        // Check for OBS mode
        if (urlParams.get('obs') === 'true') {
            isOBSMode = true;
            document.body.classList.add('obs-mode');
        }

        // Platform colors
        function getPlatformColor(platform, index) {
            const platformColors = {
                'twitch': '#9146ff',
                'youtube': '#ff0000',
                'facebook': '#1877f2',
                'instagram': '#e4405f',
                'tiktok': '#000000',
                'discord': '#5865f2',
                'kick': '#53fc18'
            };
            return platformColors[platform?.toLowerCase()] || `hsl(${index * 137.5 % 360}, 70%, 60%)`;
        }

        // Preload platform icons
        function preloadPlatformIcons(entrants, callback) {
            const entrantsList = Object.values(entrants);
            const uniquePlatforms = [...new Set(entrantsList.map(e => e.platform).filter(p => p))];
            let loadedCount = 0;
            const totalCount = uniquePlatforms.length;
            
            if (totalCount === 0) {
                callback();
                return;
            }
            
            uniquePlatforms.forEach(platform => {
                if (platformIconCache[platform]) {
                    loadedCount++;
                    if (loadedCount === totalCount) callback();
                    return;
                }
                
                const img = new Image();
                img.onload = function() {
                    platformIconCache[platform] = img;
                    loadedCount++;
                    if (loadedCount === totalCount) callback();
                };
                img.onerror = function() {
                    platformIconCache[platform] = null;
                    loadedCount++;
                    if (loadedCount === totalCount) callback();
                };
                img.src = `./sources/images/${platform.toLowerCase()}.png`;
            });
        }

        // Draw wheel function
        function drawWheel(canvas, entrants) {
            if (!canvas || !entrants) {
                return;
            }
            
            // Ensure canvas size matches its container
            const container = canvas.parentElement;
            if (container) {
                const containerRect = container.getBoundingClientRect();
                if (containerRect.width > 0 && containerRect.height > 0) {
                    canvas.width = Math.min(containerRect.width, containerRect.height);
                    canvas.height = canvas.width;
                }
            }
            
            // Preload platform icons first, then draw
            preloadPlatformIcons(entrants, function() {
                drawWheelWithIcons(canvas, entrants);
            });
        }

        function drawWheelWithIcons(canvas, entrants) {
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(centerX, centerY) - 10;
            
            const entrantsList = Object.values(entrants);
            const segmentAngle = (2 * Math.PI) / entrantsList.length;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (entrantsList.length === 0) {
                // Draw empty wheel
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                ctx.fillStyle = '#ddd';
                ctx.fill();
                ctx.strokeStyle = '#999';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#666';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Add participants to spin!', centerX, centerY);
                return;
            }
            
            // Draw wheel segments
            entrantsList.forEach((entrant, index) => {
                const startAngle = index * segmentAngle;
                const endAngle = (index + 1) * segmentAngle;
                
                // Get platform-specific color or generate one
                const segmentColor = getPlatformColor(entrant.platform, index);
                
                // Draw segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = segmentColor;
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw text and platform badge at the edge of the circle
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + segmentAngle / 2);
                
                // Position elements at the outer edge of the circle
                const edgeRadius = radius - 45; // Position near the outer edge with some padding
                const textX = edgeRadius; // Position at the edge
                const maxTextWidth = radius * 0.4; // Limit text width for edge positioning
                
                // Set up text styling for edge positioning
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Arial'; // Larger font for better visibility at edge
                ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                const userName = entrant.name || 'Anonymous';
                
                // Truncate text if too long for edge positioning
                let displayText = userName;
                if (ctx.measureText(displayText).width > maxTextWidth) {
                    while (ctx.measureText(displayText + '...').width > maxTextWidth && displayText.length > 1) {
                        displayText = displayText.slice(0, -1);
                    }
                    displayText += '...';
                }
                
                // Draw username at the edge of the circle
                ctx.fillText(displayText, textX, -12);
                
                // Draw platform icon at the edge
                if (entrant.platform) {
                    const platformIcon = platformIconCache[entrant.platform];
                    
                    if (platformIcon) {
                        // Draw platform icon at the edge below text
                        const iconSize = 24; // Larger icon for edge visibility
                        const iconX = textX - iconSize/2; // Center the icon
                        const iconY = 8; // Position below text
                        
                        // Draw icon background circle with stronger contrast
                        ctx.beginPath();
                        ctx.arc(textX, iconY + iconSize/2, iconSize/2 + 4, 0, 2 * Math.PI);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        // Draw platform icon
                        ctx.drawImage(platformIcon, iconX, iconY, iconSize, iconSize);
                    } else {
                        // Fallback to text badge at the edge
                        const platformText = entrant.platform.substring(0, 3).toUpperCase();
                        ctx.font = 'bold 14px Arial';
                        
                        // Draw badge background with stronger contrast for edge visibility
                        const badgeWidth = 36;
                        const badgeHeight = 20;
                        const badgeX = textX - badgeWidth/2;
                        const badgeY = 8;
                        
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                        ctx.fillRect(badgeX, badgeY, badgeWidth, badgeHeight);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(badgeX, badgeY, badgeWidth, badgeHeight);
                        
                        // Draw badge text
                        ctx.fillStyle = '#fff';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(platformText, textX, badgeY + badgeHeight/2);
                    }
                }
                
                ctx.restore();
            });
        }

        // Spin wheel function
        function spinWheel() {
            const canvas = document.getElementById('wheel-canvas');
            const entrantsList = Object.values(entrants);
            
            if (isSpinning) return;
            if (entrantsList.length === 0) {
                alert('Please add some participants first!');
                return;
            }
            
            isSpinning = true;
            const spinBtn = document.getElementById('spin-btn');
            const winnerDisplay = document.getElementById('winner-display');
            
            // Add loading state to button
            spinBtn.disabled = true;
            spinBtn.innerHTML = `
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Spinning...
            `;
            spinBtn.classList.add('opacity-75', 'cursor-not-allowed');
            
            // Hide winner display
            winnerDisplay.classList.add('hidden');
            winnerDisplay.classList.remove('block');
            
            const segmentAngle = 360 / entrantsList.length;
            const winnerIndex = Math.floor(Math.random() * entrantsList.length);
            
            // Calculate target angle to align winner segment with pointer (at 0 degrees / 3 o'clock position)
            // The pointer is at 0 degrees, so we need to rotate the wheel so the winner segment center aligns with it
            const winnerSegmentCenter = (winnerIndex * segmentAngle) + (segmentAngle / 2);
            // We want the winner segment center to be at 0 degrees (where the pointer is)
            // So we need to rotate by negative of the winner segment center angle
            const targetAngle = 360 - winnerSegmentCenter;
            const totalRotation = 360 * 5 + targetAngle; // 5 full rotations plus target
            
            // Convert to radians for OBS widget
            const targetRotationRadians = (totalRotation * Math.PI) / 180;
            
            // Broadcast spin state to OBS widget
            const spinState = {
                isSpinning: true,
                targetRotation: targetRotationRadians,
                duration: 4000,
                winnerIndex: winnerIndex,
                timestamp: Date.now()
            };
            localStorage.setItem('wheelSpinState', JSON.stringify(spinState));
            
            let currentRotation = 0;
            const duration = 4000; // 4 seconds
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function for smooth deceleration
                const easeOut = 1 - Math.pow(1 - progress, 3);
                currentRotation = totalRotation * easeOut;
                
                canvas.style.transform = `rotate(${currentRotation}deg)`;
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Animation complete, show winner
                    const winner = entrantsList[winnerIndex];
                    showWinner(winner);
                    isSpinning = false;
                    
                    // Restore button state
                    const spinBtn = document.getElementById('spin-btn');
                    spinBtn.disabled = false;
                    spinBtn.innerHTML = 'üéØ Spin the Wheel!';
                    spinBtn.classList.remove('opacity-75', 'cursor-not-allowed');
                    
                    // Clear spin state
                    localStorage.removeItem('wheelSpinState');
                }
            }
            
            animate();
        }

        // Show winner
        function showWinner(winner) {
            const winnerDisplay = document.getElementById('winner-display');
            const platformBadge = winner.platform ? 
                `<span class="inline-block px-2 py-1 ml-2 text-xs font-bold rounded-full bg-gradient-to-r from-purple-500 to-pink-500 text-white">${winner.platform.toUpperCase()}</span>` : '';
            
            winnerDisplay.innerHTML = `
                üéâ Winner: <strong class="text-gray-900">${winner.name}</strong> ${platformBadge}
            `;
            winnerDisplay.classList.remove('hidden');
            winnerDisplay.classList.add('block');
            
            // Broadcast winner to OBS widget
            const winnerData = {
                name: winner.name,
                platform: winner.platform,
                timestamp: Date.now()
            };
            localStorage.setItem('wheelWinner', JSON.stringify(winnerData));
            
            // Create confetti effect
            createConfetti();
            
            // Save to localStorage for OBS integration
            saveState();
            
            // Clear winner data after 6 seconds (longer than OBS display)
            setTimeout(() => {
                localStorage.removeItem('wheelWinner');
            }, 6000);
        }

        // Create confetti effect
        function createConfetti() {
            const confettiCount = 100;
            const colors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590'];
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.top = '0';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.opacity = '1';
                confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                
                const size = Math.random() * 10 + 5;
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size}px`;
                
                const shapes = ['circle', 'square', 'triangle'];
                const shape = shapes[Math.floor(Math.random() * shapes.length)];
                if (shape === 'circle') {
                    confetti.style.borderRadius = '50%';
                } else if (shape === 'triangle') {
                    confetti.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)';
                }
                
                document.body.appendChild(confetti);
                
                const animation = confetti.animate([
                    { transform: `translate(0, 0) rotate(0)`, opacity: 1 },
                    { transform: `translate(${Math.random() * 100 - 50}px, ${Math.random() * 500 + 200}px) rotate(${Math.random() * 360}deg)`, top: '100vh', opacity: 0 }
                ], {
                    duration: Math.random() * 3000 + 2000,
                    easing: 'cubic-bezier(0.1, 0.4, 0.3, 1)'
                });
                
                animation.onfinish = () => confetti.remove();
            }
        }

        // Add entrant
        function addEntrant() {
            const nameInput = document.getElementById('entrant-name');
            const platformSelect = document.getElementById('platform-select');
            const name = nameInput.value.trim();
            
            if (!name) {
                alert('Please enter a participant name');
                return;
            }
            
            const id = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            entrants[id] = {
                name: name,
                platform: platformSelect.value
            };
            
            nameInput.value = '';
            updateDisplay();
            saveState();
        }

        // Clear all entrants
        function clearEntrants() {
            if (Object.keys(entrants).length === 0) return;
            
            if (confirm('Are you sure you want to clear all participants?')) {
                entrants = {};
                updateDisplay();
                saveState();
            }
        }

        // Add test data
        function addTestData() {
            const testEntrants = [
                { name: 'Alice', platform: 'twitch' },
                { name: 'Bob', platform: 'youtube' },
                { name: 'Charlie', platform: 'facebook' },
                { name: 'Diana', platform: 'instagram' },
                { name: 'Eve', platform: 'tiktok' },
                { name: 'Frank', platform: 'discord' },
                { name: 'Grace', platform: 'kick' }
            ];
            
            testEntrants.forEach((entrant, index) => {
                const id = 'test_' + Date.now() + '_' + index;
                entrants[id] = entrant;
            });
            
            updateDisplay();
            saveState();
        }

        // Remove entrant
        function removeEntrant(id) {
            delete entrants[id];
            updateDisplay();
            saveState();
        }

        // Update display
        function updateDisplay() {
            const canvas = document.getElementById('wheel-canvas');
            const entrantsContainer = document.getElementById('entrants-container');
            const entrantCount = document.getElementById('entrant-count');
            
            // Update wheel
            drawWheel(canvas, entrants);
            
            // Update entrants list
            entrantCount.textContent = Object.keys(entrants).length;
            entrantsContainer.innerHTML = '';
            
            Object.entries(entrants).forEach(([id, entrant]) => {
                const entrantDiv = document.createElement('div');
                entrantDiv.className = 'flex justify-between items-center p-3 bg-white/5 hover:bg-white/10 rounded-lg border border-white/10 hover:border-white/20 transition-all duration-200 group';
                entrantDiv.innerHTML = `
                    <span class="flex items-center gap-2">
                        <span class="font-medium text-white">${entrant.name}</span>
                        <span class="inline-block px-2 py-1 text-xs font-bold rounded-full bg-gradient-to-r from-blue-500 to-purple-500 text-white">${entrant.platform.toUpperCase()}</span>
                    </span>
                    <button onclick="removeEntrant('${id}')" 
                            class="px-3 py-1 bg-red-500 hover:bg-red-600 text-white text-sm font-medium rounded-md transition-all duration-200 transform hover:scale-105 opacity-0 group-hover:opacity-100">
                        Remove
                    </button>
                `;
                entrantsContainer.appendChild(entrantDiv);
            });
        }

        // Save state to localStorage for project integration
        function saveState() {
            const state = {
                entrants: entrants,
                timestamp: Date.now()
            };
            localStorage.setItem('giveawayWheelState', JSON.stringify(state));
            
            // Broadcast to other instances (OBS integration)
            localStorage.setItem('giveawayWheelUpdate', JSON.stringify({
                timestamp: Date.now(),
                data: state
            }));
            setTimeout(() => {
                localStorage.removeItem('giveawayWheelUpdate');
            }, 100);
        }

        // Load state from localStorage
        function loadState() {
            try {
                const savedState = localStorage.getItem('giveawayWheelState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    if (state.entrants) {
                        entrants = state.entrants;
                        updateDisplay();
                    }
                }
            } catch (error) {
                console.error('Error loading state:', error);
            }
        }

        // Listen for state updates from other instances
        window.addEventListener('storage', function(e) {
            if (e.key === 'giveawayWheelUpdate') {
                try {
                    const update = JSON.parse(e.newValue);
                    if (update && update.data && update.data.entrants) {
                        entrants = update.data.entrants;
                        updateDisplay();
                    }
                } catch (error) {
                    console.error('Error processing state update:', error);
                }
            }
        });

        // User-controlled keyword system
        function setKeyword() {
            const keywordInput = document.getElementById('keyword-input');
            const newKeyword = keywordInput.value.trim().toUpperCase();
            
            if (newKeyword && newKeyword.length > 0) {
                currentKeyword = newKeyword;
                document.getElementById('current-keyword').textContent = currentKeyword;
                
                // Save keyword for OBS widget
                localStorage.setItem('giveaway_keyword', currentKeyword);
                localStorage.setItem('giveaway_keyword_timestamp', Date.now().toString());
                
                // Clear input
                keywordInput.value = '';
                
                console.log(`Keyword set to: ${currentKeyword}`);
                updateGiveawayState();
            }
        }

        function loadKeyword() {
            const savedKeyword = localStorage.getItem('giveaway_keyword');
            if (savedKeyword) {
                currentKeyword = savedKeyword;
                document.getElementById('current-keyword').textContent = currentKeyword;
            }
        }

        function updateGiveawayState() {
            const state = {
                participants: Object.values(entrants).map(entrant => ({
                    name: entrant.name,
                    platform: entrant.platform,
                    timestamp: Date.now(),
                    id: Date.now() + Math.random()
                })),
                title: 'Giveaway Entries',
                keyword: currentKeyword,
                timestamp: Date.now()
            };
            
            localStorage.setItem('giveaway_state', JSON.stringify(state));
        }

        function openOBSWidget() {
            const obsUrl = window.location.origin + window.location.pathname.replace('giveaway.html', 'giveaway-obs-entries.html');
            window.open(obsUrl, '_blank', 'width=800,height=600');
        }

        // Simulate chat message processing for keyword entries
        // Clear all entries function
        function clearAllEntries() {
            entrants = {};
            updateDisplay();
            saveState();
            updateGiveawayState();
            console.log('All entries cleared');
        }

        // Manual test function to simulate Social Stream messages
        function testSocialStreamMessage() {
            const testPlatforms = ['twitch', 'youtube', 'discord', 'kick', 'facebook'];
            const testUsers = ['TestUser1', 'TestUser2', 'StreamViewer', 'ChatFan', 'GiveawayLover'];
            
            const randomUser = testUsers[Math.floor(Math.random() * testUsers.length)] + Date.now();
            const randomPlatform = testPlatforms[Math.floor(Math.random() * testPlatforms.length)];
            
            // Simulate a Social Stream message structure
            const testMessage = {
                chatname: randomUser,
                chatmessage: `${currentKeyword} please! I want to win!`,
                type: randomPlatform,
                id: Date.now(),
                timestamp: Date.now()
            };
            
            console.log("Simulating Social Stream message:", testMessage);
            processGiveawayMessage(testMessage);
        }
        
        // Test WebRTC connection
        function testWebRTCConnection() {
            console.log('=== WEBRTC CONNECTION TEST ===');
            console.log('Iframe exists:', !!iframe);
            if (iframe) {
                console.log('Iframe src:', iframe.src);
                console.log('Iframe loaded:', iframe.contentDocument !== null);
                console.log('Iframe ready state:', iframe.readyState);
                
                // Try to send a test message to the iframe
                try {
                    iframe.contentWindow.postMessage({test: 'ping'}, '*');
                    console.log('Test message sent to iframe');
                } catch (error) {
                    console.error('Failed to send test message:', error);
                }
            } else {
                console.log('No iframe found!');
            }
            console.log('==============================');
        }
        
        // Add keyboard shortcuts for testing
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 't') {
                e.preventDefault();
                testSocialStreamMessage();
                console.log('Simulated Social Stream message (Ctrl+T)');
            } else if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                clearAllEntries();
                console.log('Cleared all entries (Ctrl+C)');
            } else if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                testWebRTCConnection();
            }
        });

        // Handle Enter key in name input
        document.getElementById('entrant-name').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addEntrant();
            }
        });
        
        // Handle Enter key in keyword input
        document.getElementById('keyword-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                setKeyword();
            }
        });

        // Override saveState to also update giveaway state
        const originalSaveState = saveState;
        saveState = function() {
            originalSaveState();
            updateGiveawayState();
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadState();
            loadKeyword();
            updateDisplay();
            updateGiveawayState();
            
            // Add WebSocket test button for debugging
            addWebSocketTestButton();
            
            // Connect to Social Stream WebRTC if session ID is provided
            setupWebRTCConnection();
        });
    </script>
</body>
</html>
